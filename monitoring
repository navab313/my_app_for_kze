# پروژه نمایش زنده فایل JSON محلی

## 1. مسئله
گاهی نیاز داریم داده‌های یک برنامه یا دستگاه که به‌صورت فایل JSON ذخیره شده‌اند،  
به‌صورت زنده و لحظه‌ای روی مرورگر مشاهده کنیم.  
در غیر این صورت، مجبوریم فایل را دستی باز کرده و صفحه را مرتب Refresh کنیم.

---

## 2. ضرورت پرداختن به آن
- در پروژه‌های IoT و سیستم‌های مانیتورینگ، نمایش لحظه‌ای داده‌ها ضروری است.  
- این روش برای آزمایشگاه‌ها، سرورها و پروژه‌های آموزشی بسیار کاربردی است.

---

## 3. راه‌حل ارائه‌شده
با استفاده از PHP (Server-Sent Events) و **JavaScript**،  
این پروژه فایل JSON محلی را به‌صورت زنده روی مرورگر نمایش می‌دهد.  
هر بار که محتوای فایل تغییر کند، صفحه به‌طور خودکار به‌روزرسانی می‌شود.

---

## 4. بررسی راه‌های مشابه
- وب‌سوکت (WebSocket): ارتباط دوطرفه، قدرتمند اما پیچیده‌تر.  
- AJAX Polling: نیاز به درخواست مداوم به سرور دارد، بهینه نیست.  
- SSE (Server-Sent Events): ساده و مناسب برای ارتباط یکطرفه زنده (روش استفاده شده در این پروژه).

---

## 5. توضیحات روش و مراحل فنی

### معماری
1. PHP: تغییرات فایل JSON را پایش کرده و در صورت تغییر، داده جدید را ارسال می‌کند.  
2. JavaScript: با EventSource به سرور وصل شده و داده‌ها را در صفحه به‌روز می‌کند.  
3. HTML + CSS: رابط کاربری خوانا و زیبا برای نمایش داده‌ها.

---

## 6. ساختار فنی پروژه (به صورت درختی)

### سمت سرور (PHP)
PHP (Server)  
├── SSE Connection  
│   ├── Headers  
│   │   ├── Content-Type: text/event-stream  
│   │   ├── Cache-Control: no-cache  
│   │   └── Connection: keep-alive  
│   └── Infinite Loop  
│       ├── clearstatcache()  
│       ├── file_get_contents()  
│       ├── Detect changes in file  
│       └── Send new data with echo  
└── Output  
    └── JSON (content + timestamp)  

توضیح کلی:  
- اتصال SSE برقرار می‌شود تا مرورگر همیشه به سرور متصل باشد.  
- هر بار که فایل JSON تغییر کند، محتوای جدید همراه با زمان آخرین تغییر ارسال می‌شود.

---

### سمت کلاینت (JavaScript)
JavaScript (Client)  
├── EventSource("?stream=1")  
│   ├── onmessage  
│   │   ├── Parse data  
│   │   ├── Parse JSON  
│   │   └── Update <pre> + status  
│   └── onerror  
│       └── Show error message  
└── UI (HTML + CSS)  
    ├── Container  
    ├── <pre> for JSON  
    └── Status bar (آخرین بروزرسانی)  

توضیح کلی:  
- EventSource برای دریافت داده‌های زنده استفاده می‌شود.  
- در onmessage داده جدید پردازش و روی صفحه نمایش داده می‌شود.  
- در onerror خطاها یا قطع ارتباط اطلاع‌رسانی می‌شود.  
- UI داده‌ها را در یک باکس زیبا و قابل‌خواندن نمایش می‌دهد.

---

## 7. نتایج و مزایا
- نمایش زنده داده‌ها بدون نیاز به Refresh دستی.  
- ساده و قابل‌پیاده‌سازی در پروژه‌های کوچک.  
- قابل توسعه برای سیستم‌های IoT و مانیتورینگ.

---

## 8. معایب
- وابستگی به **PHP و SSE**؛ ممکن است در همه مرورگرها یا سرورها پشتیبانی نشود.  
- ارتباط یکطرفه؛ داده فقط از سرور به کلاینت ارسال می‌شود.  
- مقیاس‌پذیری محدود برای پروژه‌های بزرگ یا با کاربران زیاد.  
- وابستگی به فایل محلی JSON؛ تغییرات سایر منابع مانیتور نمی‌شوند.  
- حلقه بی‌نهایت PHP ممکن است روی سرورهای ضعیف فشار ایجاد کند.
#  معماری سمت سرور و کلاینت (رفع اشکال و راه حل) :

## 1. مشکل و محدودیت کدنویسی سمت سرور:
کدنویسی سمت سرور برای پردازش درخواست‌های مرورگر ضروری است، اما هر رویکرد محدودیت‌هایی دارد:

### الف) کدهای مبتنی بر مفسر (PHP)
مشکلات:  
- هر درخواست یک فرآیند جدید راه‌اندازی می‌کند → سربار بالا در ترافیک زیاد  
- وضعیت کاربر نیاز به مدیریت جانبی (Session/Cookie) دارد  
- مناسب اپلیکیشن‌های بلادرنگ نیست  

راه حل / مزایا:  
- اجرای سریع و ساده برای وب‌سایت‌های سنتی و پروژه‌های کوچک  
- پیاده‌سازی آسان با فایل‌های .php روی وب‌سرور  
- مناسب برای CMSها و وبلاگ‌ها (مثل WordPress)

---

### ب) کدهای مستقل (Node.js / Python Flask)
مشکلات:  
- پیچیدگی در استقرار و پیکربندی سرویس  
- نیازمند مدیریت دائمی و نگهداری سرویس در پس‌زمینه  
- ممکن است برای پروژه‌های ساده بیش از حد پیچیده باشد  

راه حل / مزایا:  
- فرآیند واحد پیوسته، مناسب برای ترافیک بالا و برنامه‌های Real-time  
- امکان نگهداری وضعیت در حافظه، کاهش سربار نسبت به PHP  
- مناسب برای APIها، Microservices و سیستم‌های بلادرنگ  

---

2. مقایسه فنی رفع اشکال

مدل اجرا:

PHP: غیرپیوسته، هر درخواست جدا پردازش می‌شود

Node.js / Flask: پیوسته، یک فرآیند واحد به طور دائم فعال است

وابستگی:

PHP: نیاز به وب‌سرور (Apache/Nginx)

Node.js / Flask: خود برنامه به عنوان سرور عمل می‌کند

عملکرد:

PHP: کندتر در ترافیک بالا

Node.js / Flask: سریع‌تر و بهینه‌تر

مدیریت وضعیت:

PHP: نیاز به Session یا Cookie

Node.js / Flask: امکان نگهداری وضعیت در حافظه داخلی

پیچیدگی:

PHP: ساده و سریع برای شروع

Node.js / Flask: نیازمند پیکربندی و مدیریت بیشتر       
---

## 3. نتیجه‌گیری رفع اشکال
- اگر پروژه ساده و سنتی است، استفاده از PHP منطقی است.  
- اگر پروژه نیاز به بلادرنگ، مقیاس‌پذیری و مدیریت کارآمد وضعیت دارد، Node.js یا Flask انتخاب بهتری است.  

---

## 4. پیشنهادات برای توسعه پروژه
- برای سیستم‌های IoT و نمایش زنده داده‌ها، بهتر است از Node.js / Flask در کنار SSE یا WebSocket استفاده شود.  
- برای وب‌سایت‌های آموزشی و آزمایشی با ترافیک پایین، PHP با SSE کافی است.

