import socket#بریا گرفتن ادرس و api از کسنویل مورد نظر میباشد
from kivy.app import App#کلاس پایه بریا ساخت اپ با ارث بری از این ما اپلیکیشن میسازیم
from kivy.uix.boxlayout import BoxLayout#اژول چیدمان ویجت ها عمودی باشن یافقیــ>چینش جعبه ای
from kivy.uix.label import Label#نشان دهنده پیامه روی دکمه
from kivy.uix.button import Button# دکمه
from kivy.clock import Clock#زمان بنده رویداد ها
import httpx#کتاب خانه ای جدید و بعتر از requestبرای async یعنی اینه وقتی درحال پینگ هست برنامه امکان انجام کاری دیگر هم دارد
import time#برای اندازه گیری تاخیر زمانی و وقفه
from threading import Thread#اجرای تابع در یک نخ که برنامه قفل نشه برای یک فرایند
# import socketio#ما با این یک کلانت سرور میسازیم که باهاش میتوان یم به مواردی مثل مثل ایجاد یک سشن ریل تایم  با سوکت ای او داخل سرور داشته باشیم و بتوان در هر حالتی رد و بدل پیام داشه باشیم
#
# sio = socketio.Client()#ساخت یک شی مدیریت سوکت برای کلاینت که یعنی واسطه ای میشود که تقیرات مورد نیاز در ارتباط بین سوکتکلاینت و سوکت سرور

class PingLayout(BoxLayout):#این کلاس رابطه گرافیکی ما است و از boxlayoutارث بری میکند بریا کار های گرافیکی
    #self= یعنی شیکه برای ما دریچه اتصال به زخایر درون کلاس است و میتوانیم با این آرکومان که حتما به حرف سلف هم میتواند نباشد یک شی بسازیم که هرجا با دا دادن بهش دست رسی پیدا میکنیم به موارد یکه درون خود کلاس است و با این کار میتونیم  به فعالیت هایی که به کلاس وابستگی دارن ادامه دهیم و اون هارو انجام دهیم و یا اتقیراتی ایجاد کنیم
    def __init__(self,**kwargs):# یعنی با افزوده شدن هر چیزی این فرایند دوباره اجرا شود یعنی این تابع اجرا شود چون خاصیت متغیر جادویی استش و بعلاوه خاصیت ها خودش هم به شکل کیلید مقدار خواص راهم زخیره میکند و مقدار کوارگس**یعنی اگر ما خودمون هم خاصیتی اضافه کردیم مورد ایید باشد
        super().__init__(orientation="vertical",spacing=20,padding=30,**kwargs)# ما این خواص را به پدر وارث میدهیم تا درصورت ارث بردن مواردی که ما میخواهیم درونش باشد
        self.runnig=False #یک متغیر بولی درست میکنیم تا معلوم شود که مانیتور کار میکند یا خیرکه حالت اولیه خیر استا یعنی الان کار نمیکند

        self.label = Label(text="start monitoring",font_size="21sp",color=(0,1,0.8,1))#متن اوله روی صفه به رنگ فیروزه ای
        self.add_widget(self.label)#اضافه کردن لیبل به چیدمان صفه گرافیکی مون

        self.start_btn = Button(text="start-->monitoring",font_size="21sp",color=(0,1,2.1,1))
        self.start_btn.bind(on_press=self.start_ping)#ساخت دکمه گذاشتن رنگ براش و متن و اتصال رویداد کیلیک به تابع start_ping
        self.add_widget(self.start_btn)#دکمه شروع به صفه اضافه شود با استفاده از متود add_widget

        self.stop_btn = Button(text="stop-->monitoring",font_size="21sp",background_color=(1,0.2,0.4,1))# مثل بالایی برای قطع رویداد پینگ گرفتن و ارسالش تایین رنگ و موارد این قبیل
        self.stop_btn.bind(on_press=self.stop_ping)#اتصال دکمه به قطع کننده پینگ دریافت کننده
        self.add_widget(self.stop_btn)#اد کردن دکمه استوپ برای

    def start_ping(self,instance):
        if not self.runnig:
            self.runnig = True
            self.label.text="start monitoring:-)"#اگر روی این تابع کیلیک شدش و runnigما Falseبودش با ifاین سنجش اتقاف میوفتد برای اول اونو TRUE کنش و بعد متن به این تقیر پیدا کنه
            Thread(target=self.auto_ping, daemon=True).start()#ما با ساخت ترد که معنیش میشود ساخت یک رول محاسبات جدا ولی  غیر مستقل مطلق چون ما دیمون را ترو دادیم و با بسته شدن برنامه اصلی این ترد هم خاموش میشود و این یعنی  اینکه ما در ایجاد تارگت با استفاده از سلف  اتو پینگ نشانه گرفتیم که یعنی کار در کلاس و در چهار چوب کلاس باید هندلینگ شود


    def stop_ping(self,instance):
        self.runnig = False
        self.label.text="stop-->monitoring:-("

    def auto_ping(self):
        while self.runnig:
            start = time.time()#شروع رمان سنجی برای محاسبه تاریخ
            try:
                response = httpx.get('https://google.com',timeout=2)#درخواست به توجه با تیموتی که گذاشتیم میفرسته به urlکه تایین کردیم با استفاده httpxکه برای گرفتن ping بهتر از requestحساب میشود چون قابلیت مولتی ترد بودن دارد و حرفه ای تر است
                end = time.time()#دریافت زمان پاسخ
                latency = round((end - start)*1000)
                Clock.schedule_once(lambda dt: self.update_label(f"ping{latency}ms"),0)#از اون جایی که روابط گرافیکی حلقه مخصوص خودوشن دارن و از بیرون نمیشه به اصل رشته دست زد با این کار میتونیم و قتی یک موردی درون یک حلقه دیگر داریم طبقش میخواهیم چیزی درون اینم حلقه تقیر بدیم با یک درخواستی که تو شاز متود Clock.schedule_onceاستقاده کردیم میتونیم تقیر از یک ترد دیگر درون ترد مورد نظر ایجاد کنیم
                self.send_ping(latency)
            except:
                Clock.schedule_once(lambda dt: self.update_label(f"ping faild:-["),0)#نمایش خطا اگه به مشکل خوردیم
                time.sleep(1.4)
    def send_ping(self,ping_value):#ساخت تابعی برای ارسال پینگ به سرور اصلی
        try:
            device_id= socket.gethostname()#سوکت میتواند به این متود به ما اسم دیوایس یا اسم شبیه ساز را بدهد که باعث میشوود ما بتوانیم اسم دیوایس را یا اسم شبیه ساز را بگیریم و بعدش اونو به شکل یک کی به سرور ارسال کنیم تا بداند هر پینگ برای کدام دیوایس هست
            url = "http://0.0.0.0:5000/receive_ping"# این urlحاوی ای پی و پورتنامبری هست که سیستم رویش دریافت دارد و در ادامه ادرسی که سیستم رویش فقط با متود post گوش میدهد
            payload = {
                "device_id":device_id,
                "ping":ping_value
            } #میشود مقدار دیواس و مقدار پینگ که در حالت دیکشنری برای سرور اصلی ارسال میشود
            print(f"-------{payload}---------")
            response = httpx.post(url,json=payload,timeout=4.4)#اینجا ما مشخص میکنیم که از طریق httpxبه صورت پویت به urlارسال شود و مقدار ما که پایلود هست در غالب جیسون ارسال شودش و تایموت هم یعنی اینکه اگر تا 4.4ثامیه سرور جواب نداد بای بای(-:
            if response.status_code == 200:
                print("ping success send")

            else:
                print("ping failed")

        except Exception as e:
            print(e)


    def update_label(self,text):# اینجا اون تابعی میسازیم که در موارد دریافت  پینگ بهش رجوع کردیم
        self.label.text = text#و متنی که گرفته شده در اون فضا قرار داده میشود هر بار

class PingApp(App):#اینجا کلاسی میسازیم که تشکیل دهندهد ریشه uiما هست و اون هم build هستش  که میگیم از کلاس appارث بری کنه
    def build(self):#اینجا با گذاشتن buildتحت کلاس appما پایه وجود موارد گرافیکالمون چیدیم و حالا بر این زمین موارد گرافیکی نقش میبندن که به همین دلیل بعد از این PingLayoutاحضار میشود
        self.title = "Ping_monitoring"#اینجا با سلف ما به موردی اشاره داریم که الان روش درحال مانوور دادن هستیم و پایین ما با سلف یا متقیری ایجاد میکنیم یا متقیر ایجاد شده را صدا میکنیم و بهش مقداری میدیم که چون خاصیت هستش در تمام کلاس جریان دارد و تفاوتش در این است که یک متقی محلی نیست و خاصیت کلاس برای اشیا ساخته شده است
        return PingLayout() #و چیزی که مخاطب میبینه ریترن میکنیم که بیس گرافیکی ما الن ساخته شده است

if __name__ == '__main__':#موردی گه باعث میشود برنامه فقط با ران شدپن ازطریق کامتند لاین به اجرا در بی آید و از متقیر جادویی استفاده شده است
    PingApp().run()#:-/










